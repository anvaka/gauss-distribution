<!DOCTYPE html>
<meta name="robots" content="noindex">
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <meta name=Description content="Gaussian distribution...">
  <meta name=keywords content="joke, animation, Gauss">
  <meta name=author content="Andrei Kashcha">
  <title>Gaussian Distribution</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/1.3.5/chroma.min.js"></script>
</head>
<body>

<script id="jsbin-javascript">
var colorSet = new Map(); // maps color value to pixel info
var img=document.createElement('img');
var canvas = document.createElement('canvas');
var ctx;
var moveFrames = 120;
var maxColorsInBin = 0;
var currentStage = 1;
var width, height;

img.crossOrigin = 'Anonymous';

img.onload = function() {
  width = canvas.width = img.width;
  height = canvas.height = img.height;

  start();
}

img.src = 'https://i.imgur.com/iyf2bRA.png';

function start() {
  ctx = canvas.getContext('2d');
  ctx.drawImage(img,0,0);

  var width = canvas.width;
  var height = canvas.height;
  var imgData = ctx.getImageData(0, 0, width, height);
  
  var pixels = imgData.data;

  for (var x = 0; x < width; ++x) {
    for (var y = 0; y < height; ++y) {
      var i = (x + y * width) * 4;
      var r = pixels[i + 0];
      var g = pixels[i + 1];
      var b = pixels[i + 2];
      var a = pixels[i + 3];
      var color = chroma(r, g, b) 
      var colorKey = color.get('hsl.l')
      var pixelInfo = colorSet.get(colorKey);
      if (!pixelInfo) {
        pixelInfo = {
          points: [],
        };
        colorSet.set(colorKey, pixelInfo);
      }

      pixelInfo.points.push({
        x: x,
        y: y,
        timeSpan: Math.round(Math.random() * 120) + 30,
        frame: 0,
        destX: 0,
        destY: 0,
        color: color
      });

      if (pixelInfo.points.length > maxColorsInBin) maxColorsInBin = pixelInfo.points.length;
    }
  }

  computeDestinations();

  document.body.appendChild(canvas);
  setTimeout(() => {
    requestAnimationFrame(move);
  }, 1000);
}

function interploate(t) {
  return t<.5 ? 2*t*t : -1+(4-2*t)*t;
}

function lerp(a, b, t) {
  return b * t + a * (1 - t);
}

function move() {
  var hasMore = false;
  ctx.fillStyle = '#676767';
  ctx.fillRect(0, 0, width, height);
  var imgData = ctx.getImageData(0, 0, width, height);
  var pixels = imgData.data;


  colorSet.forEach((pixelInfo, colorKey) => {
    pixelInfo.points.forEach((point) => {
      var t = interploate(point.frame/point.timeSpan);
      if (currentStage === 1 && point.frame < point.timeSpan) {
        point.frame += 1;
        hasMore = true;
      }  else if (currentStage === 2 & point.frame > 0) {
        point.frame -= 1;
        hasMore = true;
        if (point.frame > 0) point.frame -= 1;
      }

      var x = Math.round(lerp(point.x, point.destX, t));
      var y = Math.round(lerp(point.y, point.destY, t));
      var pixelIndex = (x + y * width) * 4;
      var color = point.color.rgba();

      pixels[pixelIndex + 0] = color[0];
      pixels[pixelIndex + 1] = color[1];
      pixels[pixelIndex + 2] = color[2];
      pixels[pixelIndex + 3] = color[3] * 255;
    });
  });

  ctx.putImageData(imgData, 0, 0);
  
  if (!hasMore) {
    currentStage = 3 - currentStage;
    hasMore = true;
    setTimeout(() => requestAnimationFrame(move), 1000);
  } else {
    requestAnimationFrame(move);
  }
}

function computeDestinations() {
  var binCount = 256;
  var binWidth = (width/binCount);

  colorSet.forEach((pixelInfo, colorKey) => {
    var pointBin = colorKey * binCount;
    var xOffset = pointBin * binWidth;
    var yOffset = 1/maxColorsInBin;

    pixelInfo.points.forEach((point, idx) => {
      point.destX = xOffset;
      point.destY = height * 0.85 - 0.80 * height * idx /maxColorsInBin;
    })
  });
}
</script>
</body>
</html>
